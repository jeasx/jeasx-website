import Code from "../components/Code";
import Highlight from "../components/Highlight";
import IconAttention from "../components/icons/IconAttention";
import Layout from "../components/Layout";
import Lead from "../components/Lead";
import Next from "../components/Next";

<Layout
  title="Routes & Guards"
  description="Understanding how to define routes and guards"
  category="Routes & Guards"
  headline="Understanding routes"
  next={<Next link="/browser" label="How to handle browser assets?" />}
>
<Lead>
In Jeasx, a file system-based routing system is at the heart of the framework.
</Lead>

All server routes must be put anywhere in the `src` directory with filenames enclosed with brackets (`[news].jsx`) and must be defined as functions that receive [request](https://fastify.dev/docs/latest/Reference/Request) and [reply](https://fastify.dev/docs/latest/Reference/Reply) objects from Fastify as props.

Routes can be written using JSX and MDX, but can also be written in JavaScript and/or TypeScript, so supported extensions are: `.js(x)|.ts(x)|.mdx`

A route can return various types of payloads for the client, including HTML (default), JSON, or other formats. If you need to perform asynchronous operations, you can declare your route or imported components as async.

*Please note:* Jeasx doesn't specify any hardcoded outbase directory for esbuild, so it defaults to the lowest common ancestor directory for all your routes. So when you put *all* your routes into a dedicated folder (e.g. `src/routes`), `routes` will be removed from the resulting path.

## Named routes

The only rule for named routes is to enclose the base filename within brackets. This convention allows you to store components, services and utilities besides your routes without exposing them as endpoints.

<table>
<tr><th style="width:50%">Route path</th><th style="width:50%">URL</th></tr>
<tr><td>src/[index].jsx</td><td>/</td></tr>
<tr><td>src/a/b/[you-name-it].jsx</td><td>/a/b/you-name-it</td></tr>
<tr><td>src/company/[index].tsx</td><td>/company</td></tr>
<tr><td>src/images/[logo.svg].js</td><td>/images/logo.svg</td></tr>
<tr><td>src/api/posts/[update.json].ts</td><td>/api/posts/update.json</td></tr>
<tr><td>src/api/posts/utils/format.ts</td><td>This file is not exposed as endpoint.</td></tr>
</table>

### Code example

```jsx
export default function ({ request, reply }) {
  return (
    <>
      {{ html: "<!DOCTYPE html>"}}
      <html lang="en">
        <head>
          <base href={`${request.path.endsWith("/") ? request.path : request.path + "/"}`} />
          <title>Hello World</title>
        </head>
        <body>
          <h1>Hello World</h1>
        </body>
      </html>
    <>
  );
```

## Dynamic routes

Dynamic routes are wildcards designed to capture all requests for the current folder and its subfolders. They enable the creation of content with a dynamic URL structure, such as pages retrieved from a CMS. If a named route exists in the same folder as dynamic route, the named route will take precedence. The name for a dynamic route is fixed and must be: `[...path](.jsx|.js|.tsx|.ts|.mdx)`

<table>
<tr><th style="width:50%">Route path</th><th style="width:50%">URL</th></tr>
<tr><td>src/blog/[...path].jsx</td><td>/blog/article1<br />/blog/category/article2</td></tr>
</table>

### Code example

```jsx
export default async function ({ request, reply }) {
  const segments = request.path.split("/");
  const product = await (await fetch(`https://dummyjson.com/product/${segments[1]}`)).json();

  if (product.message) {
    reply.status(404);
    return;
  }

  return (
    <Layout title={product.title} description={product.description}>
      <article>
        <h1>{product.title}</h1>
        <p>{product.description}</p>
      </article>
    </Layout>
  );
}
```

## Guards

Guards enable you to intercept requests and are inherited from the root to the current folder. They are valuable for controlling access to a route. Typically, a guard does not return any payload, allowing the request to be handled by the next defined route. However, if a guard does return a payload, it will be delivered to the client, and no other route will be executed.
  
<table>
<tr><th style="width:50%">Route path</th><th style="width:50%">URL</th></tr>
<tr><td>src/blog/[...guard].jsx</td><td>The code of the guard is executed before named or dynamic routes in the current folder or below.</td></tr>
</table>

### Code example

```jsx
export default function ({ request, reply }) {
  const authorization = request.headers["authorization"];
  if (authorization !== `Basic ${Buffer.from("demo:demo").toString("base64")}`) {
    reply.header("WWW-Authenticate", 'Basic realm="Restricted Area');
    reply.status(401);
    return (
      <Layout title="Error 401">
        <h1>Error 401</h1>
        <p>You are not allowed to view this page!</p>
      </Layout>
    );
  }
}
```

Additionally, a guard has the capability to return an object, which will serve as props for all routes protected by the guard. This feature enables the creation of routes that are entirely independent from the request object, simplifying component testing.

```jsx
export default function ({ request }) {
  const body = request.body || {};
  return { message: body["message"] };
```

```jsx
export default function ({ message }) {
  return <p>{message ? message : "No message for you"}</p>;
}
```

<Highlight
  title="What is the difference between request.url, request.path and request.route?"
  icon={<IconAttention />}
>
The vanilla Fastify request object exposes the current url (e.g. `/json/api/request.json?foo=bar`) via `request.url`.

Jeasx adds two additional attributes to the Fastify request object to improve the developer experience:

- `request.path` gives you the plain path without any query parameters (e.g. `/json/api/request.json`)
- `request.route` provides the path to the current endpoint handler (e.g. `/json/[...path]`)

Have a look at the [JSON example](https://expo.jeasx.dev/json/api/request.json?foo=bar) to see `request.url, request.path, request.route` at work.
</Highlight>
</Layout>